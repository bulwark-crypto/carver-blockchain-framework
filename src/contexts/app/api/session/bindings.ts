import { Event } from '../../../../classes/interfaces/events'
import { RegisteredContext } from '../../../../classes/contextStore';
import { withContext } from '../../../../classes/logic/withContext';
import { config } from '../../../../../config';
import * as socketio from "socket.io";
import { createContextStore, ContextStore } from '../../../../classes/contextStore';
import carverUserContext from '../../carverUser/context'
import carverUserBindings from '../../carverUser/bindings'

import apiSessionContext from './context'

const bindContexts = async (contextStore: ContextStore) => {
    const apiSession = await contextStore.get(apiSessionContext);

    const io = socketio.listen(config.api.socket.port);

    const socketMap = new Map<string, socketio.Socket>();

    const usersContextStore = createContextStore({ id: 'SESSION', parent: contextStore });

    const initSocketServer = () => {

        // Hook into socket.io middleware and pass it through Carver Blockchain Framework. 
        // If command is successful there were no errors and reservation was completed successfully.
        io.use(async (socket, next) => {
            try {
                // Request new session connection. If this succeeds then connection was established successfuly.
                const id = getSocketSessionId(socket);

                await withContext(apiSession)
                    .dispatch({ type: apiSessionContext.commonLanguage.commands.Connect, payload: { id } });
            } catch (error) {
                return next(error);
            }

            return next();
        });

        io.on('connection', async (socket) => {
            const id = getSocketSessionId(socket);
            socketMap.set(id, socket);

            console.log('new socket!', id);

            const carverUser = await usersContextStore.get(carverUserContext, id);

            console.log(`Websocket User Connected: ${id}`, carverUser);

            socket.on('emit', async ({ type, payload }) => {
                // Pass down this event to the context (with the socket identifier so we know which context triggered this event). 
                // The single socket context management is done internally by "apiSession" context
                withContext(carverUser).dispatch({ type, payload });
            })

            // @todo we can issue a new socket connection event here

        })
    }
    // @todo right now socket and reservation handler live on the same server. It is possible to split these up
    initSocketServer();


    withContext(apiSession)
        .handleQuery(apiSessionContext.commonLanguage.queries.GetNewUserContext, async ({ id }) => {

            const carverUser = await usersContextStore.register({
                id,
                storeEvents: false, // Do not use event store for emitting (These events are projected out to frontend and do not need to be stored)
                context: carverUserContext
            })
            await carverUserBindings.bindContexts(usersContextStore, id);

            //@todo figure out how to pass widget events to frontend

            const forwardEventToSocket = async (event: Event) => {
                // Forward any events a user emits back to socket (ex: widgets will emit on carver user)
                if (socketMap.has(id)) {
                    socketMap.get(id).emit('emit', event)
                }
                console.log('* send to socket:', event);
            }

            console.log(`Initializing New Carver User ${id}`);

            await withContext(carverUser)
                .handleQuery(carverUserContext.commonLanguage.queries.GetNetworkStatus, async () => {
                    return {
                        usersOnline: apiSession.stateStore.state.activeSessions.length,
                    }
                })
                .streamEvents({
                    type: carverUserContext.commonLanguage.events.Widgets.Emitted, callback: forwardEventToSocket
                })
                .streamEvents({
                    type: carverUserContext.commonLanguage.events.Widgets.Removed, callback: async (event: Event) => {
                        //@todo remove from widgets context store
                        await forwardEventToSocket(event);
                    }
                })
                .dispatch({ type: carverUserContext.commonLanguage.commands.Initialize, payload: { id } });

            return {
                id
            }
        });
}

// Extract id from query params (This is the id generated by reservation rest api server)
const getSocketSessionId = (socket: socketio.Socket) => {
    return socket.handshake.query.id;
}

export default {
    bindContexts
}