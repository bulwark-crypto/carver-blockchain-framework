import { Event } from '../../../../classes/interfaces/events'
import { RegisteredContext } from '../../../../classes/contextStore';
import { withContext } from '../../../../classes/logic/withContext';
import { config } from '../../../../../config';
import * as socketio from "socket.io";
import { createContextStore, ContextStore } from '../../../../classes/contextStore';
import carverUserContext from '../../carverUser/context'
import carverUserBindings from '../../carverUser/bindings'

import apiSessionContext from './context'

import publicStateBindings from '../publicState/bindings'
import publicStateContext from '../publicState/context'

const bindContexts = async (contextStore: ContextStore) => {
    const apiSession = await contextStore.get(apiSessionContext);

    const io = socketio.listen(config.api.socket.port);
    const socketMap = new Map<string, socketio.Socket>();

    const carverUsersContextStore = createContextStore({ id: 'SESSIONS', parent: contextStore });
    const publicStatesContextStore = createContextStore({ id: 'PUBLIC_STATES', parent: contextStore });

    const forwardEventToSocket = async (id: string, event: Event) => {
        // Forward any events a user emits back to socket (ex: widgets will emit on carver user)
        if (!socketMap.has(id)) {
            throw apiSessionContext.commonLanguage.errors.IdNotFound;
        }

        const { type, ...eventWithoutType } = event;
        socketMap.get(id).emit(type, eventWithoutType)
    }

    const initSocketServer = () => {
        /**
         * Extract id from query params (This is the id generated by reservation rest api server)
         */
        const getSocketSessionId = (socket: socketio.Socket) => {
            return socket.handshake.query.id;
        }

        // Hook into socket.io middleware and pass it through Carver Blockchain Framework. 
        // If command is successful there were no errors and reservation was completed successfully.
        io.use(async (socket, next) => {
            try {
                // Request new session connection. If this succeeds then connection was established successfuly.
                const id = getSocketSessionId(socket);

                await apiSession
                    .dispatch({ type: apiSessionContext.commonLanguage.commands.Connect, payload: { id } });
            } catch (error) {
                return next(error);
            }

            return next();
        });

        io.on('connection', async (socket) => {
            const id = getSocketSessionId(socket);
            socketMap.set(id, socket);

            console.log(`Websocket User Connected: ${id}`);

            const carverUser = await carverUsersContextStore.get(carverUserContext, id);

            socket.on('emit', async ({ type, payload }) => {
                // Pass down this event to the context (with the socket identifier so we know which context triggered this event). 
                // The single socket context management is done internally by "apiSession" context
                carverUser.dispatch({ type, payload });
            });

            await carverUser.dispatch({ type: carverUserContext.commonLanguage.commands.Connect });
            // @todo we can issue a new socket connection event here
        })
    }

    // @todo right now socket and reservation handler live on the same server. It is possible to split these up
    initSocketServer();

    const createContexts = async (id: string) => {
        await carverUsersContextStore.register({
            id,
            storeEvents: false, // Do not use event store for emitting (These events are projected out to frontend and do not need to be stored)
            context: carverUserContext
        })
        await carverUserBindings.bindContexts(carverUsersContextStore, id);

        await publicStatesContextStore.register({
            id,
            storeEvents: false, // Do not use event store for emitting (These events are projected out to frontend and do not need to be stored)
            context: publicStateContext
        })
        await publicStateBindings.bindContexts(publicStatesContextStore, id);
    }

    const bindStreamsAndInitialize = async (id: string) => {
        const carverUser = await carverUsersContextStore.get(carverUserContext, id);
        const publicState = await publicStatesContextStore.get(publicStateContext, id);

        await withContext(publicState)
            // Proxy all events from a publicState to frontend
            .streamEvents({
                type: '*',

                callback: async (event) => {
                    forwardEventToSocket(id, event);
                }
            })


        await withContext(carverUser)
            .streamEvents({
                type: '*', // Forward all events from carverUser to publicState
                callback: async (event) => {

                    await publicState.dispatch({
                        type: event.type,
                        payload: { id, ...event } // event will be emitted to frontend with id (id, type, payload)
                    });
                }
            })

        await carverUser.dispatch({ type: carverUserContext.commonLanguage.commands.Initialize, payload: { id } });
        await publicState.dispatch({ type: publicStateContext.commonLanguage.commands.Initialize, payload: { id } })
    }

    withContext(apiSession)
        .handleQuery(apiSessionContext.commonLanguage.queries.InsertNewUserContext, async (id) => {
            await createContexts(id); // Create carverUser and publicState contexts
            await bindStreamsAndInitialize(id); // Then bind them

            return {
                id
            }
        });
}


export default {
    bindContexts
}