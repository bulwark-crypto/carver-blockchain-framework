import { Event } from '../../../../classes/interfaces/events'
import { RegisteredContext } from '../../../../classes/contextStore';
import { withContext } from '../../../../classes/logic/withContext';
import { config } from '../../../../../config';
import * as socketio from "socket.io";
import { createContextStore, ContextStore } from '../../../../classes/contextStore';
import carverUserContext from '../../carverUser/context'
import carverUserBindings from '../../carverUser/bindings'

import apiSessionContext from './context'

const bindContexts = async (contextStore: ContextStore) => {
    const apiSession = await contextStore.get(apiSessionContext);

    const io = socketio.listen(config.api.socket.port);

    const socketMap = new Map<string, socketio.Socket>();

    const usersContextStore = createContextStore({ id: 'SESSION', parent: contextStore });

    /**
     * Extract id from query params (This is the id generated by reservation rest api server)
     */
    const getSocketSessionId = (socket: socketio.Socket) => {
        return socket.handshake.query.id;
    }

    const initSocketServer = () => {

        // Hook into socket.io middleware and pass it through Carver Blockchain Framework. 
        // If command is successful there were no errors and reservation was completed successfully.
        io.use(async (socket, next) => {
            try {
                // Request new session connection. If this succeeds then connection was established successfuly.
                const id = getSocketSessionId(socket);

                await withContext(apiSession)
                    .dispatch({ type: apiSessionContext.commonLanguage.commands.Connect, payload: { id } });
            } catch (error) {
                return next(error);
            }

            return next();
        });

        io.on('connection', async (socket) => {
            const id = getSocketSessionId(socket);
            socketMap.set(id, socket);

            const carverUser = await usersContextStore.get(carverUserContext, id);

            console.log(`Websocket User Connected: ${id}`);
            socket.on('emit', async ({ type, payload }) => {
                // Pass down this event to the context (with the socket identifier so we know which context triggered this event). 
                // The single socket context management is done internally by "apiSession" context
                withContext(carverUser)
                    .dispatch({ type, payload });
            })

            // @todo we can issue a new socket connection event here
        })
    }

    // @todo right now socket and reservation handler live on the same server. It is possible to split these up
    initSocketServer();

    const forwardEventToSocket = async (id: string, event: Event) => {
        // Forward any events a user emits back to socket (ex: widgets will emit on carver user)
        if (socketMap.has(id)) {
            socketMap.get(id).emit('emit', event)
        }
        console.log('* send to socket:', event);
    }

    const createWidgetContext = async (id: string) => {
        const carverUser = await usersContextStore.register({
            id,
            storeEvents: false, // Do not use event store for emitting (These events are projected out to frontend and do not need to be stored)
            context: carverUserContext
        })
        await carverUserBindings.bindContexts(usersContextStore, id);

        //@todo figure out how to pass widget events to frontend

        console.log(`Initializing New Carver User ${id}`);
        await withContext(carverUser)
            .streamEvents({
                type: '*', // Forward all events to frontend
                callback: async (event) => {
                    forwardEventToSocket(id, event);
                }
            })
            .dispatch({ type: carverUserContext.commonLanguage.commands.Initialize, payload: { id } });

        return carverUser;
    }

    withContext(apiSession)
        .handleQuery(apiSessionContext.commonLanguage.queries.EmitUserPublicState, async ({ id }) => {
            // Find current public state for this user (and emit it to frontend)
            const carverUser = await usersContextStore.getById(id);
            const publicState = await carverUser.query(carverUserContext.commonLanguage.storage.FindPublicState);

            forwardEventToSocket(id, publicState);
        })
        .handleQuery(apiSessionContext.commonLanguage.queries.InsertNewUserContext, async ({ id }) => {
            await createWidgetContext(id);

            return {
                id
            }
        });
}


export default {
    bindContexts
}